---
description:
globs:
alwaysApply: false
---
# LexiLink é¡¹ç›®ç¼–ç è§„èŒƒ v1.0
# åŸºäº Godot 4.4 å®˜æ–¹æœ€ä½³å®è·µåˆ¶å®š
# æ–‡æ¡£ç±»å‹: .mdc (Markdown Code Documentation)

## ğŸ“‹ æ€»ä½“åŸåˆ™

### å¼€å‘åŸåˆ™ä¼˜å…ˆçº§ (æŒ‰åœºæ™¯åŠ¨æ€è°ƒæ•´)
```priority
# MVPå¼€å‘é˜¶æ®µ (å½“å‰)
1. YAGNI (You Aren't Gonna Need It) - åªå®ç°çœŸæ­£éœ€è¦çš„åŠŸèƒ½
2. KISS (Keep It Simple, Stupid) - ä¿æŒè®¾è®¡å’Œå®ç°ç®€å•æ€§  
3. First Principles - æ¢³ç†æ ¸å¿ƒéœ€æ±‚ä¸è¾¹ç•Œ
4. SOLID - é¢å‘å¯¹è±¡è®¾è®¡åŸåˆ™
5. DRY - æ¶ˆé™¤é‡å¤ï¼Œæç‚¼å…¬ç”¨é€»è¾‘

# åç»­è¿­ä»£é˜¶æ®µ
1. First Principles - é‡æ–°å®¡è§†éœ€æ±‚
2. SOLID - é‡æ„ä¼˜åŒ–æ¶æ„
3. YAGNI - åŠŸèƒ½æ‰©å±•è°¨æ…
4. DRY - ä»£ç å¤ç”¨æœ€å¤§åŒ–
5. KISS - ç»´æŠ¤ç®€æ´æ€§
```

### ä»£ç è´¨é‡æ ‡å‡†
- âœ… å¯è¯»æ€§ä¼˜äºæ€§èƒ½ (åœ¨æ€§èƒ½ä¸æˆé—®é¢˜æ—¶)
- âœ… ä¸­è‹±æ–‡æ³¨é‡Šæ··åˆ (è‹±æ–‡APIï¼Œä¸­æ–‡ä¸šåŠ¡é€»è¾‘)
- âœ… é˜²å¾¡å¼ç¼–ç¨‹ (nullæ£€æŸ¥ï¼Œè¾¹ç•Œå¤„ç†)
- âœ… æ¸è¿›å¼ä¼˜åŒ– (å…ˆå·¥ä½œï¼Œå†ä¼˜åŒ–)
- âœ… é”™è¯¯å¤„ç†ä¼˜å…ˆ (é¢„æœŸæ‰€æœ‰å¯èƒ½çš„å¤±è´¥)

## ğŸ”¤ å‘½åè§„èŒƒ

### GDScript å‘½åçº¦å®š
```gdscript
# ã€å˜é‡ã€‘- snake_case
var player_health: int = 100
var current_syllable_data: SyllableData
var is_dragging_enabled: bool = true
var audio_volume_multiplier: float = 1.0

# ã€å¸¸é‡ã€‘- SCREAMING_SNAKE_CASE  
const MAX_SYLLABLE_COUNT: int = 50
const DEFAULT_AUDIO_FORMAT: String = "ogg"
const CARD_RARITY_COLORS: Dictionary = {
    "common": Color.WHITE,
    "rare": Color.BLUE,
    "epic": Color.PURPLE
}

# ã€å‡½æ•°ã€‘- snake_case (åŠ¨è¯å¼€å¤´)
func initialize_game_session() -> void:
func validate_syllable_connection(from: SyllableCard, to: SyllableCard) -> bool:
func calculate_learning_progress() -> float:
func handle_drag_input_event(event: InputEvent) -> void:

# ã€ç±»åã€‘- PascalCase (åè¯)
class_name SyllableCard extends Control
class_name DragController extends Node
class_name LearningAnalytics extends RefCounted
class_name AudioManager extends AudioStreamPlayer

# ã€ä¿¡å·ã€‘- snake_case (è¿‡å»æ—¶æ€)
signal syllable_connected(from_card: SyllableCard, to_card: SyllableCard)
signal game_session_completed(score: int, accuracy: float)
signal card_collection_updated(new_card: CardData)
signal user_progress_saved(progress_data: Dictionary)

# ã€æšä¸¾ã€‘- PascalCase
enum CardRarity {
    COMMON,
    UNCOMMON, 
    RARE,
    EPIC,
    LEGENDARY
}

enum DifficultyLevel {
    BEGINNER,
    INTERMEDIATE,
    ADVANCED,
    EXPERT
}

# ã€æ–‡ä»¶åã€‘- snake_case
# è„šæœ¬: syllable_card.gd, drag_controller.gd, audio_manager.gd
# åœºæ™¯: main_menu.tscn, game_scene.tscn, card_collection.tscn
# èµ„æº: card_common.png, audio_success.ogg, font_inter_bold.ttf
```

### æ–‡ä»¶ç»„ç»‡å‘½å
```filesystem
LexiLink/
â”œâ”€â”€ scenes/           # åœºæ™¯æ–‡ä»¶
â”‚   â”œâ”€â”€ ui/              # UIç›¸å…³åœºæ™¯
â”‚   â”‚   â”œâ”€â”€ main_menu.tscn
â”‚   â”‚   â”œâ”€â”€ game_hud.tscn
â”‚   â”‚   â””â”€â”€ settings_panel.tscn
â”‚   â”œâ”€â”€ gameplay/        # æ¸¸æˆç©æ³•åœºæ™¯  
â”‚   â”‚   â”œâ”€â”€ syllable_card.tscn
â”‚   â”‚   â”œâ”€â”€ drag_area.tscn
â”‚   â”‚   â””â”€â”€ connection_line.tscn
â”‚   â””â”€â”€ managers/        # ç®¡ç†å™¨åœºæ™¯
â”‚       â”œâ”€â”€ audio_manager.tscn
â”‚       â””â”€â”€ progress_tracker.tscn
â”œâ”€â”€ scripts/          # è„šæœ¬æ–‡ä»¶
â”‚   â”œâ”€â”€ core/            # æ ¸å¿ƒç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ game_manager.gd
â”‚   â”‚   â”œâ”€â”€ data_manager.gd
â”‚   â”‚   â””â”€â”€ scene_manager.gd
â”‚   â”œâ”€â”€ gameplay/        # æ¸¸æˆé€»è¾‘
â”‚   â”‚   â”œâ”€â”€ syllable_card.gd
â”‚   â”‚   â”œâ”€â”€ drag_controller.gd
â”‚   â”‚   â””â”€â”€ connection_validator.gd
â”‚   â”œâ”€â”€ ui/              # UIæ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ menu_controller.gd
â”‚   â”‚   â”œâ”€â”€ hud_controller.gd
â”‚   â”‚   â””â”€â”€ settings_controller.gd
â”‚   â””â”€â”€ utils/           # å·¥å…·ç±»
â”‚       â”œâ”€â”€ audio_utils.gd
â”‚       â”œâ”€â”€ tween_utils.gd
â”‚       â””â”€â”€ validation_utils.gd
â”œâ”€â”€ data/             # æ•°æ®æ–‡ä»¶
â”‚   â”œâ”€â”€ syllables/       # éŸ³èŠ‚æ•°æ®
â”‚   â”œâ”€â”€ cards/           # å¡ç‰‡æ•°æ®
â”‚   â””â”€â”€ levels/          # å…³å¡é…ç½®
â”œâ”€â”€ assets/           # èµ„æºæ–‡ä»¶
â”‚   â”œâ”€â”€ audio/           # éŸ³é¢‘èµ„æº
â”‚   â”œâ”€â”€ textures/        # çº¹ç†å›¾ç‰‡
â”‚   â””â”€â”€ fonts/           # å­—ä½“æ–‡ä»¶
â””â”€â”€ docs/             # æ–‡æ¡£
    â”œâ”€â”€ api/             # APIæ–‡æ¡£
    â””â”€â”€ design/          # è®¾è®¡æ–‡æ¡£
```

## ğŸ¨ ä»£ç æ ¼å¼è§„èŒƒ

### ç¼©è¿›ä¸ç©ºæ ¼
```gdscript
# ã€ç¼©è¿›ã€‘- ä½¿ç”¨Tabå­—ç¬¦ (Godoté»˜è®¤)
# ã€è¡Œå®½ã€‘- æœ€å¤§100å­—ç¬¦ (ç§»åŠ¨è®¾å¤‡å‹å¥½)
# ã€ç©ºè¡Œã€‘- é€»è¾‘å—ä¹‹é—´ç©ºä¸€è¡Œ

class_name SyllableCard extends Control

# ç±»å˜é‡å£°æ˜åŒºåŸŸ
@export var syllable_text: String = ""
@export var card_rarity: CardRarity = CardRarity.COMMON

var is_selected: bool = false
var drag_offset: Vector2 = Vector2.ZERO

# ä¿¡å·å£°æ˜åŒºåŸŸ  
signal card_selected(card: SyllableCard)
signal drag_started(position: Vector2)

# è™šå‡½æ•°é‡å†™åŒºåŸŸ
func _ready() -> void:
    initialize_card_appearance()
    connect_signals()

func _input(event: InputEvent) -> void:
    if event is InputEventMouseButton:
        handle_mouse_click(event)

# å…¬å…±å‡½æ•°åŒºåŸŸ
func set_syllable_data(data: SyllableData) -> void:
    syllable_text = data.text
    card_rarity = data.rarity
    update_visual_appearance()

# ç§æœ‰å‡½æ•°åŒºåŸŸ
func _initialize_card_appearance() -> void:
    # å®ç°ç»†èŠ‚...
    pass

func _connect_signals() -> void:
    # ä¿¡å·è¿æ¥...
    pass
```

### æ³¨é‡Šè§„èŒƒ
```gdscript
## ç±»çº§æ³¨é‡Š - ç®€è¦æè¿°ç±»çš„èŒè´£å’Œç”¨æ³•
## è¿™ä¸ªç±»è´Ÿè´£å¤„ç†éŸ³èŠ‚å¡ç‰‡çš„æ˜¾ç¤ºå’Œäº¤äº’
## æ”¯æŒæ‹–æ‹½ã€é€‰æ‹©ã€è¿æ¥ç­‰æ“ä½œ
class_name SyllableCard extends Control

# ã€å¯¼å‡ºå˜é‡æ³¨é‡Šã€‘- è¯´æ˜é…ç½®é¡¹ç”¨é€”
@export var syllable_text: String = ""  ## æ˜¾ç¤ºåœ¨å¡ç‰‡ä¸Šçš„éŸ³èŠ‚æ–‡æœ¬
@export var is_draggable: bool = true   ## æ˜¯å¦å…è®¸æ‹–æ‹½æ“ä½œ

# ã€ä¸šåŠ¡é€»è¾‘æ³¨é‡Šã€‘- ä¸­æ–‡è§£é‡Šå¤æ‚é€»è¾‘
func validate_connection(target_card: SyllableCard) -> bool:
    # æ£€æŸ¥éŸ³èŠ‚è¿æ¥è§„åˆ™ï¼š
    # 1. å…ƒéŸ³åé¢åªèƒ½è·Ÿè¾…éŸ³
    # 2. è¾…éŸ³åé¢å¯ä»¥è·Ÿå…ƒéŸ³æˆ–ç‰¹å®šè¾…éŸ³
    # 3. ä¸èƒ½è¿æ¥ç›¸åŒç±»å‹çš„éŸ³èŠ‚
    
    var current_type = get_syllable_type()
    var target_type = target_card.get_syllable_type()
    
    match current_type:
        SyllableType.VOWEL:
            return target_type == SyllableType.CONSONANT
        SyllableType.CONSONANT:
            return target_type in [SyllableType.VOWEL, SyllableType.LIQUID]
        _:
            return false

# ã€TODOæ³¨é‡Šã€‘- æ ‡è®°å¾…å®Œæˆé¡¹
func optimize_performance() -> void:
    # TODO: å®ç°éŸ³é¢‘é¢„åŠ è½½ç¼“å­˜
    # TODO: æ·»åŠ å¡ç‰‡åŠ¨ç”»æ± å¤ç”¨
    # FIXME: ä¿®å¤åœ¨ä½ç«¯è®¾å¤‡ä¸Šçš„å¡é¡¿é—®é¢˜
    pass

# ã€APIæ–‡æ¡£æ³¨é‡Šã€‘- å…¬å…±æ¥å£è¯´æ˜
## è®¾ç½®å¡ç‰‡çš„éŸ³èŠ‚æ•°æ®å¹¶æ›´æ–°æ˜¾ç¤º
## @param data: åŒ…å«éŸ³èŠ‚æ–‡æœ¬ã€ç±»å‹ã€ç¨€æœ‰åº¦ç­‰ä¿¡æ¯çš„æ•°æ®å¯¹è±¡
## @return: æ— è¿”å›å€¼ï¼Œç›´æ¥æ›´æ–°å¡ç‰‡çŠ¶æ€
func set_syllable_data(data: SyllableData) -> void:
    assert(data != null, "éŸ³èŠ‚æ•°æ®ä¸èƒ½ä¸ºç©º")
    
    syllable_text = data.text
    syllable_type = data.type
    card_rarity = data.rarity
    
    _update_visual_appearance()
```

### é”™è¯¯å¤„ç†æ¨¡å¼
```gdscript
# ã€é˜²å¾¡å¼ç¼–ç¨‹ã€‘- å‚æ•°éªŒè¯
func play_syllable_audio(syllable: String) -> void:
    if syllable.is_empty():
        push_warning("å°è¯•æ’­æ”¾ç©ºéŸ³èŠ‚éŸ³é¢‘")
        return
    
    if not audio_manager:
        push_error("éŸ³é¢‘ç®¡ç†å™¨æœªåˆå§‹åŒ–")
        return
    
    audio_manager.play_syllable(syllable)

# ã€èµ„æºåŠ è½½é”™è¯¯å¤„ç†ã€‘
func load_syllable_texture(syllable_id: String) -> Texture2D:
    var texture_path = "res://assets/syllables/%s.png" % syllable_id
    
    if not ResourceLoader.exists(texture_path):
        push_warning("éŸ³èŠ‚çº¹ç†ä¸å­˜åœ¨: %s" % texture_path)
        return preload("res://assets/ui/default_card.png")  # å¤‡ç”¨çº¹ç†
    
    var texture = load(texture_path)
    if not texture:
        push_error("æ— æ³•åŠ è½½éŸ³èŠ‚çº¹ç†: %s" % texture_path)
        return preload("res://assets/ui/default_card.png")
    
    return texture

# ã€ç”¨æˆ·è¾“å…¥éªŒè¯ã€‘
func handle_syllable_input(input_text: String) -> bool:
    # è¾“å…¥å†…å®¹éªŒè¯
    if input_text.length() == 0:
        show_error_message("è¯·è¾“å…¥éŸ³èŠ‚å†…å®¹")
        return false
    
    if input_text.length() > MAX_SYLLABLE_LENGTH:
        show_error_message("éŸ³èŠ‚é•¿åº¦ä¸èƒ½è¶…è¿‡%dä¸ªå­—ç¬¦" % MAX_SYLLABLE_LENGTH)
        return false
    
    # å­—ç¬¦æœ‰æ•ˆæ€§æ£€æŸ¥
    var regex = RegEx.new()
    regex.compile("^[a-zA-Z]+$")
    if not regex.search(input_text):
        show_error_message("éŸ³èŠ‚åªèƒ½åŒ…å«è‹±æ–‡å­—æ¯")
        return false
    
    return true
```

## ğŸ§ª æµ‹è¯•è§„èŒƒ

### å•å…ƒæµ‹è¯•æ¨¡å¼
```gdscript
# test_syllable_validator.gd
extends GutTest

var validator: SyllableValidator

func before_each():
    validator = SyllableValidator.new()

func test_vowel_consonant_connection_valid():
    # æµ‹è¯•å…ƒéŸ³+è¾…éŸ³è¿æ¥ï¼ˆåº”è¯¥æœ‰æ•ˆï¼‰
    var vowel_card = create_test_card("a", SyllableType.VOWEL)
    var consonant_card = create_test_card("t", SyllableType.CONSONANT)
    
    var result = validator.validate_connection(vowel_card, consonant_card)
    
    assert_true(result, "å…ƒéŸ³åè¿æ¥è¾…éŸ³åº”è¯¥æœ‰æ•ˆ")

func test_consonant_consonant_connection_invalid():
    # æµ‹è¯•è¾…éŸ³+è¾…éŸ³è¿æ¥ï¼ˆåº”è¯¥æ— æ•ˆï¼‰
    var consonant1 = create_test_card("b", SyllableType.CONSONANT)
    var consonant2 = create_test_card("d", SyllableType.CONSONANT)
    
    var result = validator.validate_connection(consonant1, consonant2)
    
    assert_false(result, "ç›¸åŒè¾…éŸ³è¿æ¥åº”è¯¥æ— æ•ˆ")

func test_empty_syllable_validation():
    # æµ‹è¯•ç©ºéŸ³èŠ‚éªŒè¯
    var empty_card = create_test_card("", SyllableType.VOWEL)
    
    var result = validator.is_valid_syllable(empty_card)
    
    assert_false(result, "ç©ºéŸ³èŠ‚åº”è¯¥æ— æ•ˆ")

func create_test_card(text: String, type: SyllableType) -> SyllableCard:
    var card = SyllableCard.new()
    var data = SyllableData.new()
    data.text = text
    data.type = type
    card.set_syllable_data(data)
    return card
```

### é›†æˆæµ‹è¯•æ¨¡å¼
```gdscript
# test_game_flow.gd
extends GutTest

var game_scene: GameScene
var input_mocker: InputEventMocker

func before_each():
    game_scene = preload("res://scenes/gameplay/game_scene.tscn").instantiate()
    add_child(game_scene)
    input_mocker = InputEventMocker.new()

func test_complete_syllable_connection_flow():
    # æµ‹è¯•å®Œæ•´çš„éŸ³èŠ‚è¿æ¥æµç¨‹
    
    # 1. ç­‰å¾…æ¸¸æˆåˆå§‹åŒ–å®Œæˆ
    await game_scene.initialization_completed
    
    # 2. æ¨¡æ‹Ÿæ‹–æ‹½ç¬¬ä¸€ä¸ªéŸ³èŠ‚å¡ç‰‡
    var first_card = game_scene.get_syllable_card(0)
    input_mocker.simulate_drag_start(first_card.global_position)
    
    # 3. æ‹–æ‹½åˆ°ç›®æ ‡ä½ç½®
    var target_position = game_scene.get_connection_area().global_position
    input_mocker.simulate_drag_motion(target_position)
    
    # 4. é‡Šæ”¾å¡ç‰‡
    input_mocker.simulate_drag_end()
    
    # 5. éªŒè¯è¿æ¥ç»“æœ
    await game_scene.connection_validation_completed
    assert_true(game_scene.has_valid_connection(), "åº”è¯¥åˆ›å»ºæœ‰æ•ˆè¿æ¥")
    
    # 6. éªŒè¯éŸ³é¢‘æ’­æ”¾
    assert_true(game_scene.audio_manager.is_playing(), "åº”è¯¥æ’­æ”¾è¿æ¥éŸ³æ•ˆ")

func test_invalid_connection_feedback():
    # æµ‹è¯•æ— æ•ˆè¿æ¥çš„ç”¨æˆ·åé¦ˆ
    
    var vowel_card = game_scene.get_vowel_card()
    var another_vowel = game_scene.get_another_vowel_card()
    
    # å°è¯•è¿æ¥ä¸¤ä¸ªå…ƒéŸ³ï¼ˆæ— æ•ˆæ“ä½œï¼‰
    game_scene.attempt_connection(vowel_card, another_vowel)
    
    await game_scene.feedback_animation_completed
    
    # éªŒè¯é”™è¯¯åé¦ˆ
    assert_true(game_scene.error_feedback_shown, "åº”è¯¥æ˜¾ç¤ºé”™è¯¯åé¦ˆ")
    assert_false(game_scene.has_valid_connection(), "ä¸åº”è¯¥åˆ›å»ºè¿æ¥")
```

## ğŸ”„ ç‰ˆæœ¬æ§åˆ¶è§„èŒƒ

### Commit æ¶ˆæ¯æ ¼å¼
```bash
# ã€æ ¼å¼ã€‘type(scope): description
# ã€ç±»å‹ã€‘å¿…é¡»æ˜¯ä»¥ä¸‹ä¹‹ä¸€:
# feat:     æ–°åŠŸèƒ½
# fix:      bugä¿®å¤
# docs:     æ–‡æ¡£æ›´æ–°
# style:    ä»£ç æ ¼å¼(ä¸å½±å“åŠŸèƒ½)
# refactor: é‡æ„(æ—¢ä¸ä¿®å¤bugä¹Ÿä¸æ·»åŠ åŠŸèƒ½)
# test:     æµ‹è¯•ç›¸å…³
# chore:    æ„å»ºå·¥å…·ã€ä¾èµ–æ›´æ–°

# ã€èŒƒå›´ã€‘å¯é€‰ï¼ŒæŒ‡æ˜ä¿®æ”¹çš„æ¨¡å—:
# ui, audio, gameplay, data, networking

# ã€ç¤ºä¾‹ã€‘
feat(gameplay): æ·»åŠ éŸ³èŠ‚æ‹–æ‹½è¿æ¥éªŒè¯åŠŸèƒ½
fix(audio): ä¿®å¤éŸ³é¢‘åœ¨Androidè®¾å¤‡ä¸Šçš„æ’­æ”¾å»¶è¿Ÿ
docs(api): æ›´æ–°SyllableCardç±»çš„ä½¿ç”¨æ–‡æ¡£  
style(ui): ç»Ÿä¸€æŒ‰é’®æ ·å¼å’Œé—´è·
refactor(data): é‡æ„ç”¨æˆ·è¿›åº¦æ•°æ®å­˜å‚¨ç»“æ„
test(gameplay): æ·»åŠ è¿æ¥éªŒè¯çš„å•å…ƒæµ‹è¯•
chore(build): æ›´æ–°Godotç‰ˆæœ¬åˆ°4.4.1

# ã€å¤šè¡Œæäº¤æ¶ˆæ¯ç¤ºä¾‹ã€‘
feat(roguelike): å®ç°éšæœºå…³å¡ç”Ÿæˆç³»ç»Ÿ

- æ·»åŠ å…³å¡ç”Ÿæˆå™¨ç±»
- å®ç°éŸ³èŠ‚æ± éšæœºæ‰“ä¹±ç®—æ³•  
- æ”¯æŒéš¾åº¦é€’è¿›æœºåˆ¶
- æ·»åŠ ç‰¹æ®Šäº‹ä»¶è§¦å‘é€»è¾‘

ç›¸å…³Issue: #23, #24
æµ‹è¯•è¦†ç›–: æ ¸å¿ƒç®—æ³•100%
```

### åˆ†æ”¯ç®¡ç†ç­–ç•¥
```bash
# ã€åˆ†æ”¯å‘½åè§„èŒƒã€‘
main                    # ç”Ÿäº§åˆ†æ”¯ï¼Œæ°¸è¿œä¿æŒå¯å‘å¸ƒçŠ¶æ€
develop                 # å¼€å‘ä¸»åˆ†æ”¯ï¼Œé›†æˆæ‰€æœ‰åŠŸèƒ½
feature/syllable-drag   # åŠŸèƒ½åˆ†æ”¯ï¼ŒéŸ³èŠ‚æ‹–æ‹½åŠŸèƒ½
feature/card-collection # åŠŸèƒ½åˆ†æ”¯ï¼Œå¡ç‰‡æ”¶è—ç³»ç»Ÿ
hotfix/audio-bug-fix    # ç´§æ€¥ä¿®å¤åˆ†æ”¯
release/v1.0.0          # å‘å¸ƒåˆ†æ”¯ï¼Œå‡†å¤‡v1.0.0ç‰ˆæœ¬

# ã€å·¥ä½œæµç¨‹ã€‘
1. ä»developåˆ›å»ºfeatureåˆ†æ”¯
2. åœ¨featureåˆ†æ”¯å¼€å‘å’Œæµ‹è¯•
3. å®Œæˆåmergeå›develop
4. å‡†å¤‡å‘å¸ƒæ—¶ä»developåˆ›å»ºreleaseåˆ†æ”¯
5. releaseæµ‹è¯•é€šè¿‡åmergeåˆ°mainå¹¶æ‰“tag
6. ç´§æ€¥é—®é¢˜ä»mainåˆ›å»ºhotfixåˆ†æ”¯
```

### è‡ªåŠ¨åŒ–è„šæœ¬
```bash
#!/bin/bash
# auto_commit.sh - æ¯æ—¥è‡ªåŠ¨æäº¤è„šæœ¬

# è·å–å½“å‰æ—¥æœŸå’Œæ—¶é—´
TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
BRANCH=$(git branch --show-current)

# æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
if [[ -n $(git status --porcelain) ]]; then
    echo "æ£€æµ‹åˆ°æœªæäº¤çš„æ›´æ”¹ï¼Œå¼€å§‹è‡ªåŠ¨æäº¤..."
    
    # æ·»åŠ æ‰€æœ‰æ›´æ”¹
    git add .
    
    # æ£€æŸ¥ä»Šå¤©æ˜¯å¦å·²æœ‰å¤šä¸ªcommit
    TODAY=$(date "+%Y-%m-%d")
    COMMIT_COUNT=$(git log --since="$TODAY 00:00:00" --oneline | wc -l)
    
    if [[ $COMMIT_COUNT -gt 3 ]]; then
        echo "ä»Šæ—¥æäº¤æ•°é‡è¿‡å¤š($COMMIT_COUNT)ï¼Œæ‰§è¡Œcommitæ•´åˆ..."
        
        # è½¯é‡ç½®åˆ°ä»Šå¤©ç¬¬ä¸€ä¸ªcommit
        FIRST_COMMIT=$(git log --since="$TODAY 00:00:00" --format="%H" | tail -1)
        git reset --soft $FIRST_COMMIT^
        
        # é‡æ–°æäº¤æ•´åˆåçš„æ›´æ”¹
        git commit -m "chore(daily): æ•´åˆ $TODAY çš„å¼€å‘è¿›åº¦

- éŸ³èŠ‚æ‹–æ‹½ç³»ç»Ÿä¼˜åŒ–
- UIç•Œé¢è°ƒæ•´
- ä»£ç é‡æ„å’Œä¼˜åŒ–
- Bugä¿®å¤

æäº¤æ•´åˆ: $COMMIT_COUNT ä¸ªcommit"
        
        echo "å·²æ•´åˆä»Šæ—¥çš„ $COMMIT_COUNT ä¸ªcommit"
    else
        # æ­£å¸¸æäº¤
        git commit -m "chore(daily): æ¯æ—¥å¼€å‘è¿›åº¦æäº¤ - $TIMESTAMP

è‡ªåŠ¨æäº¤åŒ…å«:
- ä»£ç ä¿®æ”¹å’Œä¼˜åŒ–
- èµ„æºæ–‡ä»¶æ›´æ–°
- æ–‡æ¡£è¡¥å……

åˆ†æ”¯: $BRANCH"
    fi
    
    echo "è‡ªåŠ¨æäº¤å®Œæˆ: $TIMESTAMP"
else
    echo "æ²¡æœ‰æ£€æµ‹åˆ°æ›´æ”¹ï¼Œè·³è¿‡æäº¤"
fi
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è§„èŒƒ

### å†…å­˜ç®¡ç†
```gdscript
# ã€å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‘
class_name CardManager extends Node

var card_pool: Array[SyllableCard] = []  # å¡ç‰‡å¯¹è±¡æ± 
var active_cards: Array[SyllableCard] = [] # å½“å‰æ¿€æ´»çš„å¡ç‰‡

func get_card_from_pool() -> SyllableCard:
    # ä¼˜å…ˆä»å¯¹è±¡æ± è·å–ï¼Œé¿å…é¢‘ç¹åˆ›å»º/é”€æ¯
    if card_pool.size() > 0:
        return card_pool.pop_back()
    else:
        return preload("res://scenes/gameplay/syllable_card.tscn").instantiate()

func return_card_to_pool(card: SyllableCard) -> void:
    # é‡ç½®å¡ç‰‡çŠ¶æ€å¹¶å›æ”¶åˆ°å¯¹è±¡æ± 
    card.reset_state()
    card.visible = false
    active_cards.erase(card)
    card_pool.append(card)

# ã€èµ„æºé¢„åŠ è½½ç­–ç•¥ã€‘
func preload_essential_resources() -> void:
    # é¢„åŠ è½½å¿…éœ€èµ„æºï¼Œé¿å…æ¸¸æˆä¸­åŠ è½½å¡é¡¿
    var essential_textures = [
        "res://assets/cards/common_card.png",
        "res://assets/cards/rare_card.png",
        "res://assets/ui/connection_line.png"
    ]
    
    for texture_path in essential_textures:
        ResourceLoader.load_threaded_request(texture_path)
    
    # é¢„åŠ è½½éŸ³é¢‘èµ„æº
    AudioManager.preload_common_sounds()
```

### æ¸²æŸ“ä¼˜åŒ–
```gdscript
# ã€æ‰¹é‡æ¸²æŸ“ä¼˜åŒ–ã€‘
extends Control
class_name OptimizedCardRenderer

@export var max_visible_cards: int = 20  # é™åˆ¶åŒæ—¶æ¸²æŸ“çš„å¡ç‰‡æ•°é‡

func _ready() -> void:
    # å¯ç”¨è£å‰ªä¼˜åŒ–
    clip_contents = true
    
    # è®¾ç½®æ›´æ–°é¢‘ç‡
    set_process_mode(Node.PROCESS_MODE_WHEN_PAUSED)

func update_card_visibility() -> void:
    # åªæ¸²æŸ“è§†å£å†…çš„å¡ç‰‡
    var viewport_rect = get_viewport_rect()
    var visible_count = 0
    
    for card in all_cards:
        var card_rect = Rect2(card.global_position, card.size)
        var is_in_viewport = viewport_rect.intersects(card_rect)
        
        if is_in_viewport and visible_count < max_visible_cards:
            card.visible = true
            visible_count += 1
        else:
            card.visible = false

# ã€åŠ¨ç”»æ€§èƒ½ä¼˜åŒ–ã€‘
func create_optimized_tween() -> Tween:
    var tween = create_tween()
    tween.set_process_mode(Tween.TWEEN_PROCESS_IDLE)  # ä½¿ç”¨ç©ºé—²æ—¶é—´å¤„ç†
    tween.set_ease(Tween.EASE_OUT)
    tween.set_trans(Tween.TRANS_CUBIC)
    return tween
```

### éŸ³é¢‘ä¼˜åŒ–
```gdscript
# ã€éŸ³é¢‘æµç®¡ç†ã€‘
extends AudioStreamPlayer
class_name OptimizedAudioPlayer

var audio_cache: Dictionary = {}  # éŸ³é¢‘ç¼“å­˜
var max_cache_size: int = 50     # æœ€å¤§ç¼“å­˜æ•°é‡

func play_syllable_audio(syllable_id: String) -> void:
    var audio_stream = get_cached_audio(syllable_id)
    if audio_stream:
        stream = audio_stream
        play()

func get_cached_audio(syllable_id: String) -> AudioStream:
    # æ£€æŸ¥ç¼“å­˜
    if syllable_id in audio_cache:
        return audio_cache[syllable_id]
    
    # åŠ è½½æ–°éŸ³é¢‘
    var audio_path = "res://assets/audio/syllables/%s.ogg" % syllable_id
    if ResourceLoader.exists(audio_path):
        var audio_stream = load(audio_path)
        
        # ç®¡ç†ç¼“å­˜å¤§å°
        if audio_cache.size() >= max_cache_size:
            # ç§»é™¤æœ€å°‘ä½¿ç”¨çš„éŸ³é¢‘
            var oldest_key = audio_cache.keys()[0]
            audio_cache.erase(oldest_key)
        
        audio_cache[syllable_id] = audio_stream
        return audio_stream
    
    return null
```

## ğŸ“± è·¨å¹³å°å…¼å®¹æ€§

### è¾“å…¥å¤„ç†ç»Ÿä¸€
```gdscript
# ã€ç»Ÿä¸€è¾“å…¥å¤„ç†ã€‘
extends Control
class_name CrossPlatformInputHandler

func _input(event: InputEvent) -> void:
    # ç»Ÿä¸€å¤„ç†é¼ æ ‡å’Œè§¦å±è¾“å…¥
    if event is InputEventMouseButton or event is InputEventScreenTouch:
        handle_pointer_down(get_pointer_position(event), event.pressed)
    elif event is InputEventMouseMotion or event is InputEventScreenDrag:
        handle_pointer_motion(get_pointer_position(event))

func get_pointer_position(event: InputEvent) -> Vector2:
    if event is InputEventMouse:
        return event.position
    elif event is InputEventScreenTouch:
        return event.position
    elif event is InputEventScreenDrag:
        return event.position
    return Vector2.ZERO

func handle_pointer_down(pos: Vector2, pressed: bool) -> void:
    # æ ¹æ®å¹³å°è°ƒæ•´è§¦æ§å“åº”
    var touch_radius = 30.0 if OS.has_feature("mobile") else 10.0
    
    for card in get_cards_in_area(pos, touch_radius):
        if pressed:
            card.on_touch_started()
        else:
            card.on_touch_ended()
```

### åˆ†è¾¨ç‡é€‚é…
```gdscript
# ã€å“åº”å¼UIå¸ƒå±€ã€‘
extends Control
class_name ResponsiveLayout

@export var base_resolution: Vector2 = Vector2(1080, 1920)  # åŸºå‡†åˆ†è¾¨ç‡
@export var min_scale: float = 0.5
@export var max_scale: float = 2.0

func _ready() -> void:
    # ç›‘å¬è§†å£å¤§å°å˜åŒ–
    get_viewport().size_changed.connect(_on_viewport_size_changed)
    _update_layout()

func _on_viewport_size_changed() -> void:
    _update_layout()

func _update_layout() -> void:
    var current_size = get_viewport().get_visible_rect().size
    var scale_factor = calculate_scale_factor(current_size)
    
    # åº”ç”¨ç¼©æ”¾
    scale = Vector2.ONE * scale_factor
    
    # è°ƒæ•´å­—ä½“å¤§å°
    update_font_sizes(scale_factor)
    
    # é‡æ–°å¸ƒå±€UIå…ƒç´ 
    rearrange_ui_elements()

func calculate_scale_factor(screen_size: Vector2) -> float:
    var width_scale = screen_size.x / base_resolution.x
    var height_scale = screen_size.y / base_resolution.y
    
    # ä½¿ç”¨è¾ƒå°çš„ç¼©æ”¾æ¯”ä¾‹ä¿è¯å®Œæ•´æ˜¾ç¤º
    var scale_factor = min(width_scale, height_scale)
    
    return clamp(scale_factor, min_scale, max_scale)
```

---

## ğŸ“‹ ç¼–ç æ£€æŸ¥æ¸…å•

### æäº¤å‰æ£€æŸ¥ (æ¯æ¬¡commitå‰)
- [ ] ä»£ç ç¬¦åˆå‘½åè§„èŒƒ
- [ ] å…³é”®é€»è¾‘æ·»åŠ äº†æ³¨é‡Š
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] å†…å­˜æ³„æ¼æ£€æŸ¥
- [ ] è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯•
- [ ] æ€§èƒ½å½±å“è¯„ä¼°

### åŠŸèƒ½å®Œæˆæ£€æŸ¥ (æ¯ä¸ªfeatureå®Œæˆæ—¶)
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡>80%
- [ ] é›†æˆæµ‹è¯•é€šè¿‡
- [ ] ç”¨æˆ·ä½“éªŒæµ‹è¯•
- [ ] ä»£ç å®¡æŸ¥å®Œæˆ
- [ ] æ–‡æ¡£æ›´æ–°
- [ ] å¤šè®¾å¤‡æµ‹è¯•éªŒè¯

### å‘å¸ƒå‰æ£€æŸ¥ (releaseå‰)
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] æ€§èƒ½åŸºå‡†è¾¾æ ‡
- [ ] å†…å­˜ä½¿ç”¨åˆç†
- [ ] å¤šå¹³å°æ„å»ºæˆåŠŸ
- [ ] ç”¨æˆ·æ¥å—åº¦æµ‹è¯•
- [ ] å®‰å…¨æ€§æ£€æŸ¥

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åŸºäº**: Godot 4.4å®˜æ–¹Style Guide + LexiLinké¡¹ç›®éœ€æ±‚  
**æ›´æ–°é¢‘ç‡**: éšé¡¹ç›®æ¼”è¿›åŠ¨æ€è°ƒæ•´  
**ç»´æŠ¤è€…**: LexiLinkå¼€å‘å›¢é˜Ÿ
